// Variables
int player_pos = 0;
int number_of_actions = 0;
int dice_outcome;
bool round_complete = false;    // lock, only true in states with final player position (i.e. after bounce and special fields)

// Constants
int goal = 7;       // the goal field
int bound = 4;      // to make the model finite

// Has to roll 1, 2, 2, 2
property winning = E F player_pos == goal && number_of_actions <= bound &  round_complete;

while( player_pos != goal & number_of_actions <= bound){
    // Roll the die
    alt{
      ::tau {= round_complete = false, dice_outcome = 1 =}
      ::tau {= round_complete = false, dice_outcome = 2 =}
      //::tau {= round_complete = false, dice_outcome = 3 =}
      //::tau {= round_complete = false, dice_outcome = 4 =}
      //::tau {= round_complete = false, dice_outcome = 5 =}
      //::tau {= round_complete = false, dice_outcome = 6 =}
    };
    tau {= number_of_actions = number_of_actions + 1, player_pos = (player_pos + dice_outcome) =};

    // Bounce back from goal
    if(player_pos > goal)
      { tau{= player_pos = (goal - (player_pos - goal)) =} }
    else
      { tau };

    // Implement special rules (hier: Felder 2 und 4 muessen Ã¼bersprungen werden)
    alt{
        ::when( player_pos == 2 ) { tau {= player_pos = 0 =} }
        ::when( player_pos == 4 ) { tau {= player_pos = 0 =} }
        ::when( player_pos != 2 & player_pos != 4) { tau };
    };
    tau {= round_complete = true =};
}